---
title: "CVE-2020-0002"
date: 2020-01-08 12:19:15 +0000
draft: false

avd_page_type: nvd_page

date_published: 2020-01-08 12:19:15 +0000
date_modified: 2020-01-29 12:21:15 +0000

header_subtitle: "Generation of Error Message Containing Sensitive Information"

sidebar_additional_info_nvd: "https://nvd.nist.gov/vuln/detail/CVE-2020-0002"
sidebar_additional_info_cwe: "https://cwe.mitre.org/data/definitions/416.html"

cvss_nvd_v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
cvss_nvd_v3_score: "8.8"
cvss_nvd_v3_severity: "HIGH"

cvss_nvd_v2_vector: "AV:N/AC:M/Au:N/C:C/I:C/A:C"
cvss_nvd_v2_score: "9.3"
cvss_nvd_v2_severity: "HIGH"

redhat_v2_vector: "-"
redhat_v2_score: "0"
redhat_v2_severity: "-"

redhat_v3_vector: "-"
redhat_v3_score: "0"
redhat_v3_severity: "-"

ubuntu_vector: "-"
ubuntu_score: "-"
ubuntu_severity: "-"

---

In ih264d_init_decoder of ih264d_api.c, there is a possible out of bounds write due to a use after free. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation Product: Android Versions: Android-8.0, Android-8.1, Android-9, and Android-10 Android ID: A-142602711

<<<<<<< HEAD

### Title
Use After Free

=======
>>>>>>> master
### Weakness {.with_icon .weakness}
Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.

### Affected Software {.with_icon .affected_software}
| Name | Vendor           | Start Version | End Version |
| ------------- |-------------|-----|----|
| Android | Google | 8.0 | 8.0|
| Android | Google | 8.1 | 8.1|
| Android | Google | 9.0 | 9.0|
| Android | Google | 10.0 | 10.0|

### Extended Description
The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes:

               
            
In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process.
If the newly allocated data chances to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.

### Potential Mitigations {.with_icon .mitigations}


### References  {.with_icon .references}
- https://source.android.com/security/bulletin/2020-01-01

<!--- Add Aqua content below --->